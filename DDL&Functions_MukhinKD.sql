/* 
Функция для генерации случайной последовательности цифр - возвращаемый тип int:
create or replace function random_string_num(num integer, chars text default '123456789') returns int as 
$$
declare
res_str text := '';
begin
	if num < 1 then
		raise exception 'invalid length';
 	end if;
 	for __ IN 1..num 
 	loop
		res_str := res_str || substr(chars, floor(random() * length(chars))::int + 1, 1);
 	end loop;
	return res_str::int;
end;
$$ language plpgsql;

Функция для генерации случайной последовательности символов - возвращаемый тип text:
create or replace function random_string(num integer, chars text default '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz') returns text as 
$$
declare
res_str text := '';
begin
	if num < 1 then
		raise exception 'invalid length';
 	end if;
 	for __ IN 1..num 
 	loop
		res_str := res_str || substr(chars, floor(random() * length(chars))::int + 1, 1);
 	end loop;
	return res_str;
end;
$$ language plpgsql;
*/



-- Создание таблицы и полседовательности для хранения городов:
create table if not exists cities (
	city_id bigint,
	city_name varchar(50) unique not null,
	constraint pk_city_id primary key(city_id)
); -- drop table cities cascade;

create sequence "public"."seq_cities" increment 1 start 1; -- drop sequence "public"."seq_cities" cascade;
alter table cities alter column city_id set default nextval('"public"."seq_cities"');
alter sequence "public"."seq_cities" restart with 1;

insert into cities (city_name) values 
	('Москва'), -- 4 млн.
	('Оренбург'), -- 500 тыс.
	('Орск'), -- 300 тыс. 
	('Глазов'), -- 150 тыс.
	('Бузулук'); -- 50 тыс.
	
select * from cities;

/*
Созданная архитектура для данной задачи реализована слеующим образом: в PostgreSQL есть ограничение по количество колонок ~1600,
а также ограничение ~1600 на вывод атрибутов в selcet, а нам требуется 1700 атрибутов для каждой метрики -> исходя из этого были созданы 
1 родительская таблица и 4 дочерних таблиц по 340 атрибутов, связанных общим идентификатором, в дальнейшем для увеличения количества метрик(2700) 
предусматривается создание еще 3х дочерних таблиц по 340 и 320 атрибутов соответственно. Все таблицы (родительская и дочерняя) были также 
секционированны деларативным способом сперва по хэшу(для равномерного распределения данных), далее по временных диапазонам (в нашем случае это три месяца
январь, февраль и март). Также для каждой таблицы был создан btree индекс по атрибутам id, surname, firname, city_id, metrics_insdt.
Частично была реализована автоматическая генерация отношений и данных.
*/

-- Создание родительской таблицы(все последующий запросы будут обращаться именно к ней с присоединением inner дочерних):
create table if not exists metrics (
	id bigint generated by default as identity, 
	surname varchar(10),
	firname varchar(10),
	city_id bigint not null,
	metrics_insdt timestamp,
	constraint fk_metrics foreign key (city_id) references cities(city_id),
	constraint uq_metrics unique (id, surname, firname, city_id, metrics_insdt)
) partition by hash (id); 


-- Функция по созданию 4 дочерних отношений(1700 метрик):
do $$
declare
table_name varchar(50);
fk_name varchar(50);
fk_1_name varchar(50);
uq_name varchar(50);
iter int := 1;

begin
	while iter <= 4
	loop
		table_name := replace('metrics_'||to_char(iter, '9'), ' ', '');
		fk_name := replace('fk_metrics_'||to_char(iter, '9'), ' ', '');
		fk_1_name := replace('fk_1_metrics_'||to_char(iter, '9'), ' ', '');
		uq_name := replace('uq_metrics_'||to_char(iter, '9'), ' ', '');
		execute format(
		'create table if not exists %I (
		id bigint generated by default as identity,
		surname varchar(10),
		firname varchar(10),
		city_id int not null,
		metrics_insdt timestamp default now()::timestamp,
		constraint %I foreign key (city_id) references cities(city_id),
		constraint %I unique (id, surname, firname, city_id, metrics_insdt), 
		constraint %I foreign key (id, surname, firname, city_id, metrics_insdt) references metrics(id, surname, firname, city_id, metrics_insdt)
		) partition by hash (id)', table_name, fk_name, uq_name, fk_1_name);	
		
		raise notice 'table_name: %', table_name;
		iter := iter + 1;
	end loop;
end;
$$ language plpgsql;

-- Проверка на создание 4 дочерних отношений(1700 метрик):
select * from information_schema.tables where table_name ilike 'metrics%';

-- функция по созданию 3 дочерних отношений(2700 метрик):
do $$
declare
table_name varchar(50);
fk_name varchar(50);
uq_name varchar(50);
iter int := 1;

begin
	while iter <= 7
	loop
		table_name := replace('metrics_'||to_char(iter, '9'), ' ', '');
		fk_name := replace('fk_metrics_'||to_char(iter, '9'), ' ', '');
		uq_name := replace('uq_metrics_'||to_char(iter, '9'), ' ', '');
		execute format(
		'create table if not exists %I (
		id bigint generated by default as identity,
		surname varchar(10),
		firname varchar(10),
		city_id int not null,
		metrics_insdt timestamp default now()::timestamp,
		constraint %I foreign key (city_id) references cities(city_id),
		constraint %I unique (id, surname, firname, city_id, metrics_insdt)
		) partition by hash (id)', table_name, fk_name, uq_name);	
		
		raise notice 'table_name: %', table_name;
		iter := iter + 1;
	end loop;
end;
$$ language plpgsql;

-- Функция удаления всех таблиц(metrics):
do $$
declare
r varchar(50);

begin
	for r in (select table_name from information_schema.tables where table_name ilike 'metrics__' or table_name ilike 'metrics')
	loop
		execute format('drop table %I cascade', r);
--		raise notice 'Table: %', r;
	end loop;
end;
$$ language plpgsql;

-- Ручное удаление таблиц:
drop table metrics cascade;
drop table metrics_1 cascade;
drop table metrics_2 cascade;
drop table metrics_3 cascade;
drop table metrics_4 cascade;
drop table metrics_5 cascade;
drop table metrics_6 cascade;
drop table metrics_7 cascade;


-- Функция генерации 1700 уникальных колонок для каждой созданной таблицы:
do $$
declare 
arg varchar(5);
col bigint := 1;
r varchar(50);

begin
	while col <= 340
	loop
		for r in (select table_name from information_schema.tables where table_name ilike 'metrics__' or table_name ilike 'metrics')
		loop
			arg := lower(random_string(5, 'abcdefghijklmnopqrstuvwxyz'));
			if not exists (select column_name from information_schema.columns where (table_name ilike 'metrics__' or table_name ilike 'metrics') and column_name = arg) then 
				execute format('alter table %I add column if not exists %I int default random_string_num(3)', r, arg); -- здесь в рамках генерации данных поставил генерируемое значение по умолчанию
			else
				raise notice 'Already exists: %', arg;
			end if;
		end loop;
		col := col + 1;
	end loop;
end;
$$ language plpgsql;

-- Функция генерации 2700 уникальных колонок для каждой созданной таблицы(логика перегружена, но работает, переделывать не стал):
do $$
declare 
arg varchar(5);
col bigint := 1;
col_1 bigint := 1;
r varchar(50);
i varchar(50);

begin
	for i in (select table_name from information_schema.tables where table_name ilike 'metrics%')
	loop 
		if i in ('metrics_5', 'metrics_6') then
			while col <= 340
			loop
				for r in (select table_name from information_schema.tables where table_name in ('metrics_5', 'metrics_6'))
				loop
					arg := random_string(5);
					if not exists (select column_name from information_schema.columns where table_name ilike 'metrics%' and column_name = arg) then 
						execute format('alter table %I add column if not exists %I int default random_string_num(3)', r, arg);
					else
						raise notice 'Already exists: %', arg;
					end if;
				end loop;
				col := col + 1;
			end loop;
		elsif i in ('metrics_7') then
			while col_1 <= 320
			loop
				for r in (select table_name from information_schema.tables where table_name in ('metrics_7'))
				loop
					arg := random_string(5);
					if not exists (select column_name from information_schema.columns where table_name ilike 'metrics%' and column_name = arg) then 
						execute format('alter table %I add column if not exists %I int default random_string_num(3)', r, arg);
					else
						raise notice 'Already exists: %', arg;
					end if;
				end loop;
				col_1 := col_1 + 1;
			end loop;
		end if;
	end loop;	
end;
$$ language plpgsql;

-- Проверка на создание 1700 уникальных колонок c учетом партиций(не должно быть уникальных)
select count(distinct(column_name)) from information_schema.columns where table_name ilike 'metrics%';

-- создание партиций
-- metrics
create table if not exists metrics_hash_1 partition of metrics for values with (MODULUS 5, REMAINDER 0) partition by range (metrics_insdt);
create table if not exists metrics_hash_2 partition of metrics for values with (MODULUS 5, REMAINDER 1) partition by range (metrics_insdt);
create table if not exists metrics_hash_3 partition of metrics for values with (MODULUS 5, REMAINDER 2) partition by range (metrics_insdt);
create table if not exists metrics_hash_4 partition of metrics for values with (MODULUS 5, REMAINDER 3) partition by range (metrics_insdt);
create table if not exists metrics_hash_5 partition of metrics for values with (MODULUS 5, REMAINDER 4) partition by range (metrics_insdt);

create table if not exists metrics_hash_1_2022_01 partition of metrics_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_hash_1_2022_02 partition of metrics_hash_1 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_hash_1_2022_03 partition of metrics_hash_1 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_hash_2_2022_01 partition of metrics_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_hash_2_2022_02 partition of metrics_hash_2 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_hash_2_2022_03 partition of metrics_hash_2 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_hash_3_2022_01 partition of metrics_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_hash_3_2022_02 partition of metrics_hash_3 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_hash_3_2022_03 partition of metrics_hash_3 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_hash_4_2022_01 partition of metrics_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_hash_4_2022_02 partition of metrics_hash_4 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_hash_4_2022_03 partition of metrics_hash_4 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_hash_5_2022_01 partition of metrics_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_hash_5_2022_02 partition of metrics_hash_5 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_hash_5_2022_03 partition of metrics_hash_5 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');


-- metrics_1
create table if not exists metrics_1_hash_1 partition of metrics_1 for values with (MODULUS 5, REMAINDER 0) partition by range (metrics_insdt);
create table if not exists metrics_1_hash_2 partition of metrics_1 for values with (MODULUS 5, REMAINDER 1) partition by range (metrics_insdt);
create table if not exists metrics_1_hash_3 partition of metrics_1 for values with (MODULUS 5, REMAINDER 2) partition by range (metrics_insdt);
create table if not exists metrics_1_hash_4 partition of metrics_1 for values with (MODULUS 5, REMAINDER 3) partition by range (metrics_insdt);
create table if not exists metrics_1_hash_5 partition of metrics_1 for values with (MODULUS 5, REMAINDER 4) partition by range (metrics_insdt);

create table if not exists metrics_1_hash_1_2022_01 partition of metrics_1_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_1_hash_1_2022_02 partition of metrics_1_hash_1 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_1_hash_1_2022_03 partition of metrics_1_hash_1 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_1_hash_2_2022_01 partition of metrics_1_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_1_hash_2_2022_02 partition of metrics_1_hash_2 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_1_hash_2_2022_03 partition of metrics_1_hash_2 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_1_hash_3_2022_01 partition of metrics_1_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_1_hash_3_2022_02 partition of metrics_1_hash_3 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_1_hash_3_2022_03 partition of metrics_1_hash_3 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_1_hash_4_2022_01 partition of metrics_1_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_1_hash_4_2022_02 partition of metrics_1_hash_4 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_1_hash_4_2022_03 partition of metrics_1_hash_4 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_1_hash_5_2022_01 partition of metrics_1_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_1_hash_5_2022_02 partition of metrics_1_hash_5 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_1_hash_5_2022_03 partition of metrics_1_hash_5 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');


-- metrics_2
create table if not exists metrics_2_hash_1 partition of metrics_2 for values with (MODULUS 5, REMAINDER 0) partition by range (metrics_insdt);
create table if not exists metrics_2_hash_2 partition of metrics_2 for values with (MODULUS 5, REMAINDER 1) partition by range (metrics_insdt);
create table if not exists metrics_2_hash_3 partition of metrics_2 for values with (MODULUS 5, REMAINDER 2) partition by range (metrics_insdt);
create table if not exists metrics_2_hash_4 partition of metrics_2 for values with (MODULUS 5, REMAINDER 3) partition by range (metrics_insdt);
create table if not exists metrics_2_hash_5 partition of metrics_2 for values with (MODULUS 5, REMAINDER 4) partition by range (metrics_insdt);

create table if not exists metrics_2_hash_1_2022_01 partition of metrics_2_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_2_hash_1_2022_02 partition of metrics_2_hash_1 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_2_hash_1_2022_03 partition of metrics_2_hash_1 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_2_hash_2_2022_01 partition of metrics_2_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_2_hash_2_2022_02 partition of metrics_2_hash_2 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_2_hash_2_2022_03 partition of metrics_2_hash_2 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_2_hash_3_2022_01 partition of metrics_2_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_2_hash_3_2022_02 partition of metrics_2_hash_3 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_2_hash_3_2022_03 partition of metrics_2_hash_3 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_2_hash_4_2022_01 partition of metrics_2_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_2_hash_4_2022_02 partition of metrics_2_hash_4 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_2_hash_4_2022_03 partition of metrics_2_hash_4 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_2_hash_5_2022_01 partition of metrics_2_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_2_hash_5_2022_02 partition of metrics_2_hash_5 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_2_hash_5_2022_03 partition of metrics_2_hash_5 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

-- metrics_3
create table if not exists metrics_3_hash_1 partition of metrics_3 for values with (MODULUS 5, REMAINDER 0) partition by range (metrics_insdt);
create table if not exists metrics_3_hash_2 partition of metrics_3 for values with (MODULUS 5, REMAINDER 1) partition by range (metrics_insdt);
create table if not exists metrics_3_hash_3 partition of metrics_3 for values with (MODULUS 5, REMAINDER 2) partition by range (metrics_insdt);
create table if not exists metrics_3_hash_4 partition of metrics_3 for values with (MODULUS 5, REMAINDER 3) partition by range (metrics_insdt);
create table if not exists metrics_3_hash_5 partition of metrics_3 for values with (MODULUS 5, REMAINDER 4) partition by range (metrics_insdt);

create table if not exists metrics_3_hash_1_2022_01 partition of metrics_3_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_3_hash_1_2022_02 partition of metrics_3_hash_1 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_3_hash_1_2022_03 partition of metrics_3_hash_1 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_3_hash_2_2022_01 partition of metrics_3_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_3_hash_2_2022_02 partition of metrics_3_hash_2 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_3_hash_2_2022_03 partition of metrics_3_hash_2 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_3_hash_3_2022_01 partition of metrics_3_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_3_hash_3_2022_02 partition of metrics_3_hash_3 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_3_hash_3_2022_03 partition of metrics_3_hash_3 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_3_hash_4_2022_01 partition of metrics_3_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_3_hash_4_2022_02 partition of metrics_3_hash_4 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_3_hash_4_2022_03 partition of metrics_3_hash_4 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_3_hash_5_2022_01 partition of metrics_3_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_3_hash_5_2022_02 partition of metrics_3_hash_5 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_3_hash_5_2022_03 partition of metrics_3_hash_5 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

-- metrics_4
create table if not exists metrics_4_hash_1 partition of metrics_4 for values with (MODULUS 5, REMAINDER 0) partition by range (metrics_insdt);
create table if not exists metrics_4_hash_2 partition of metrics_4 for values with (MODULUS 5, REMAINDER 1) partition by range (metrics_insdt);
create table if not exists metrics_4_hash_3 partition of metrics_4 for values with (MODULUS 5, REMAINDER 2) partition by range (metrics_insdt);
create table if not exists metrics_4_hash_4 partition of metrics_4 for values with (MODULUS 5, REMAINDER 3) partition by range (metrics_insdt);
create table if not exists metrics_4_hash_5 partition of metrics_4 for values with (MODULUS 5, REMAINDER 4) partition by range (metrics_insdt);

create table if not exists metrics_4_hash_1_2022_01 partition of metrics_4_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_4_hash_1_2022_02 partition of metrics_4_hash_1 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_4_hash_1_2022_03 partition of metrics_4_hash_1 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_4_hash_2_2022_01 partition of metrics_4_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_4_hash_2_2022_02 partition of metrics_4_hash_2 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_4_hash_2_2022_03 partition of metrics_4_hash_2 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_4_hash_3_2022_01 partition of metrics_4_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_4_hash_3_2022_02 partition of metrics_4_hash_3 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_4_hash_3_2022_03 partition of metrics_4_hash_3 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_4_hash_4_2022_01 partition of metrics_4_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_4_hash_4_2022_02 partition of metrics_4_hash_4 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_4_hash_4_2022_03 partition of metrics_4_hash_4 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

create table if not exists metrics_4_hash_5_2022_01 partition of metrics_4_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_4_hash_5_2022_02 partition of metrics_4_hash_5 for values from (timestamp'2022-02-01 00:00:00.000') to (timestamp'2022-03-01 00:00:00.000');
create table if not exists metrics_4_hash_5_2022_03 partition of metrics_4_hash_5 for values from (timestamp'2022-03-01 00:00:00.000') to (timestamp'2022-04-01 00:00:00.000');

-- Создание партиций для таблиц на 2700 метрик:
-- metrics_5
create table if not exists metrics_5_hash_1 partition of metrics_5 for values with (MODULUS 5, REMAINDER 0) partition by range (metrics_insdt);
create table if not exists metrics_5_hash_2 partition of metrics_5 for values with (MODULUS 5, REMAINDER 1) partition by range (metrics_insdt);
create table if not exists metrics_5_hash_3 partition of metrics_5 for values with (MODULUS 5, REMAINDER 2) partition by range (metrics_insdt);
create table if not exists metrics_5_hash_4 partition of metrics_5 for values with (MODULUS 5, REMAINDER 3) partition by range (metrics_insdt);
create table if not exists metrics_5_hash_5 partition of metrics_5 for values with (MODULUS 5, REMAINDER 4) partition by range (metrics_insdt);

create table if not exists metrics_5_hash_1_2022_01 partition of metrics_5_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_5_hash_1_2022_02 partition of metrics_5_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_5_hash_1_2022_03 partition of metrics_5_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_5_hash_2_2022_01 partition of metrics_5_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_5_hash_2_2022_02 partition of metrics_5_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_5_hash_2_2022_03 partition of metrics_5_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_5_hash_3_2022_01 partition of metrics_5_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_5_hash_3_2022_02 partition of metrics_5_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_5_hash_3_2022_03 partition of metrics_5_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_5_hash_4_2022_01 partition of metrics_5_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_5_hash_4_2022_02 partition of metrics_5_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_5_hash_4_2022_03 partition of metrics_5_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_5_hash_5_2022_01 partition of metrics_5_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_5_hash_5_2022_02 partition of metrics_5_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_5_hash_5_2022_03 partition of metrics_5_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

-- metrics_6
create table if not exists metrics_6_hash_1 partition of metrics_6 for values with (MODULUS 5, REMAINDER 0) partition by range (metrics_insdt);
create table if not exists metrics_6_hash_2 partition of metrics_6 for values with (MODULUS 5, REMAINDER 1) partition by range (metrics_insdt);
create table if not exists metrics_6_hash_3 partition of metrics_6 for values with (MODULUS 5, REMAINDER 2) partition by range (metrics_insdt);
create table if not exists metrics_6_hash_4 partition of metrics_6 for values with (MODULUS 5, REMAINDER 3) partition by range (metrics_insdt);
create table if not exists metrics_6_hash_5 partition of metrics_6 for values with (MODULUS 5, REMAINDER 4) partition by range (metrics_insdt);

create table if not exists metrics_6_hash_1_2022_01 partition of metrics_6_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_6_hash_1_2022_02 partition of metrics_6_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_6_hash_1_2022_03 partition of metrics_6_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_6_hash_2_2022_01 partition of metrics_6_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_6_hash_2_2022_02 partition of metrics_6_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_6_hash_2_2022_03 partition of metrics_6_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_6_hash_3_2022_01 partition of metrics_6_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_6_hash_3_2022_02 partition of metrics_6_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_6_hash_3_2022_03 partition of metrics_6_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_6_hash_4_2022_01 partition of metrics_6_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_6_hash_4_2022_02 partition of metrics_6_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_6_hash_4_2022_03 partition of metrics_6_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_6_hash_5_2022_01 partition of metrics_6_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_6_hash_5_2022_02 partition of metrics_6_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_6_hash_5_2022_03 partition of metrics_6_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

-- metrics_7
create table if not exists metrics_7_hash_1 partition of metrics_7 for values with (MODULUS 5, REMAINDER 0) partition by range (metrics_insdt);
create table if not exists metrics_7_hash_2 partition of metrics_7 for values with (MODULUS 5, REMAINDER 1) partition by range (metrics_insdt);
create table if not exists metrics_7_hash_3 partition of metrics_7 for values with (MODULUS 5, REMAINDER 2) partition by range (metrics_insdt);
create table if not exists metrics_7_hash_4 partition of metrics_7 for values with (MODULUS 5, REMAINDER 3) partition by range (metrics_insdt);
create table if not exists metrics_7_hash_5 partition of metrics_7 for values with (MODULUS 5, REMAINDER 4) partition by range (metrics_insdt);

create table if not exists metrics_7_hash_1_2022_01 partition of metrics_7_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_7_hash_1_2022_02 partition of metrics_7_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_7_hash_1_2022_03 partition of metrics_7_hash_1 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_7_hash_2_2022_01 partition of metrics_7_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_7_hash_2_2022_02 partition of metrics_7_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_7_hash_2_2022_03 partition of metrics_7_hash_2 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_7_hash_3_2022_01 partition of metrics_7_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_7_hash_3_2022_02 partition of metrics_7_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_7_hash_3_2022_03 partition of metrics_7_hash_3 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_7_hash_4_2022_01 partition of metrics_7_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_7_hash_4_2022_02 partition of metrics_7_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_7_hash_4_2022_03 partition of metrics_7_hash_4 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');

create table if not exists metrics_7_hash_5_2022_01 partition of metrics_7_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_7_hash_5_2022_02 partition of metrics_7_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');
create table if not exists metrics_7_hash_5_2022_03 partition of metrics_7_hash_5 for values from (timestamp'2022-01-01 00:00:00.000') to (timestamp'2022-02-01 00:00:00.000');


-- Функции по генерации данных в таблицы за 3 месяца по 1 часу(2159 часов) по каждому человеку:
do $$
declare
col_1 bigint := 1;
col bigint := 1;
inter bigint := 1;
surname_ varchar(10);
firname_ varchar(10);

begin 
	while col_1 <= 45
	loop
		surname_ := random_string(10);
		firname_ := random_string(10);
		while col <= 2159
		loop
			insert into metrics (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 5, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_1 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 5, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_2 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 5, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_3 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 5, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_4 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 5, timestamp'2022-01-01' + interval '1 hour' * inter);
			inter := inter + 1;
			col := col + 1;
		end loop;
		col := 1;
		inter := 1;
		col_1 := col_1 + 1;
	end loop;
end;
$$ language plpgsql;

do $$
declare
col_1 bigint := 1;
col bigint := 1;
inter bigint := 1;
surname_ varchar(10);
firname_ varchar(10);

begin 
	while col_1 <= 45
	loop
		surname_ := random_string(10);
		firname_ := random_string(10);
		while col <= 2159
		loop
			insert into metrics (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 4, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_1 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 4, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_2 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 4, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_3 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 4, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_4 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 4, timestamp'2022-01-01' + interval '1 hour' * inter);
			inter := inter + 1;
			col := col + 1;
		end loop;
		col := 1;
		inter := 1;
		col_1 := col_1 + 1;
	end loop;
end;
$$ language plpgsql;

do $$
declare
col_1 bigint := 1;
col bigint := 1;
inter bigint := 1;
surname_ varchar(10);
firname_ varchar(10);

begin 
	while col_1 <= 45
	loop
		surname_ := random_string(10);
		firname_ := random_string(10);
		while col <= 2159
		loop
			insert into metrics (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 3, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_1 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 3, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_2 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 3, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_3 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 3, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_4 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 3, timestamp'2022-01-01' + interval '1 hour' * inter);
			inter := inter + 1;
			col := col + 1;
		end loop;
		col := 1;
		inter := 1;
		col_1 := col_1 + 1;
	end loop;
end;
$$ language plpgsql;

do $$
declare
col_1 bigint := 1;
col bigint := 1;
inter bigint := 1;
surname_ varchar(10);
firname_ varchar(10);

begin 
	while col_1 <= 45
	loop
		surname_ := random_string(10);
		firname_ := random_string(10);
		while col <= 2159
		loop
			insert into metrics (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 2, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_1 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 2, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_2 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 2, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_3 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 2, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_4 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 2, timestamp'2022-01-01' + interval '1 hour' * inter);
			inter := inter + 1;
			col := col + 1;
		end loop;
		col := 1;
		inter := 1;
		col_1 := col_1 + 1;
	end loop;
end;
$$ language plpgsql;

do $$
declare
col_1 bigint := 1;
col bigint := 1;
inter bigint := 1;
surname_ varchar(10);
firname_ varchar(10);

begin 
	while col_1 <= 45
	loop
		surname_ := random_string(10);
		firname_ := random_string(10);
		while col <= 2159
		loop
			insert into metrics (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 1, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_1 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 1, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_2 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 1, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_3 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 1, timestamp'2022-01-01' + interval '1 hour' * inter);
			insert into metrics_4 (surname, firname, city_id, metrics_insdt) values (surname_, firname_, 1, timestamp'2022-01-01' + interval '1 hour' * inter);
			inter := inter + 1;
			col := col + 1;
		end loop;
		col := 1;
		inter := 1;
		col_1 := col_1 + 1;
	end loop;
end;
$$ language plpgsql;

-- проверяем импорт данных
select count(*) from metrics;
select count(*) from metrics_1;
select count(*) from metrics_2;
select count(*) from metrics_3;
select count(*) from metrics_4;

-- делаем выборку атрибутов с каждой таблицы
select * from metrics; -- twsph -> AwrYYWbrlC | I4AEBwPsBJ -- уникальный человек
select * from metrics_1; -- ezevs
select * from metrics_2; -- qpesh
select * from metrics_3; -- hoblp
select * from metrics_4; -- lanzp

-- проверяем выборку данных (все успешно импортировано)
select m.surname, m.firname, m.city_id, m.metrics_insdt, twsph, ezevs, qpesh, hoblp, lanzp 
from metrics m
inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
where m.surname = 'AwrYYWbrlC' and m.firname = 'I4AEBwPsBJ' order by m.metrics_insdt;


-- функция №1 (работает)
create or replace function find_human(surname_ varchar(10), firname_ varchar(10)=null) returns refcursor as $$
declare 
ref_cursor refcursor := 'ref_cursor';
begin
	open ref_cursor for select surname, firname, city_id, min(metrics_insdt) as min_metrics_insdt, max(metrics_insdt) as max_metrics_insdt 
	from metrics 
	where surname = surname_ or firname = firname_
	group by surname, firname, city_id;
	return ref_cursor;
end;
$$ language plpgsql;

-- вывод рефкурсора Фамилия и Имя:
begin transaction;
select find_people('AwrYYWbrlC', 'I4AEBwPsBJ');
fetch all in ref_cursor;
commit transaction;

-- вывод рефкурсора Фамилия:
begin transaction;
select find_people('AwrYYWbrlC');
fetch all in ref_cursor;
commit transaction;

/* Тесты:
-- день
with cte as (select m.surname, m.firname, m.city_id, date_trunc('day', m.metrics_insdt) as period_day, twsph
from metrics m
inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
where m.surname = 'AwrYYWbrlC' and m.firname = 'I4AEBwPsBJ')
select distinct surname, firname, city_id, period_day, sum(twsph) over(partition by surname, firname, city_id, period_day order by period_day) from cte 
order by period_day;

-- неделя
with cte as (select m.surname, m.firname, m.city_id, date_trunc('week', m.metrics_insdt) as period_week, twsph
from metrics m
inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
where m.surname = 'AwrYYWbrlC' and m.firname = 'I4AEBwPsBJ')
select distinct surname, firname, city_id, period_week, sum(twsph) over(partition by surname, firname, city_id, period_week order by period_week) from cte 
order by period_week;

-- месяц
with cte as (select m.surname, m.firname, m.city_id, date_trunc('month', m.metrics_insdt) as period_month, twsph
from metrics m
inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
where m.surname = 'AwrYYWbrlC' and m.firname = 'I4AEBwPsBJ')
select distinct surname, firname, city_id, period_month, sum(twsph) over(partition by surname, firname, city_id, period_month order by period_month) as twsph from cte 
order by period_month;
*/

-- функция №2 (работает)
create or replace function find_human_metrics(surname_ text, firname_ text, metrics_ text, period_start_ timestamp=null, period_stop_ timestamp=null, period_d_w_m_ text=null) returns refcursor as $$
declare 
row_text_s text := '1700 metrics';
row_text_b text := '2700 metrics';
ref_cursor refcursor := 'ref_cursor';
day_ text := quote_ident('day');
week_ text := quote_ident('week');
month_ text := quote_ident('month');
row_list_x text;
row_list_y text array;
row_fin text;

begin 
	if not exists (select * from information_schema.tables where table_name in ('metrics_5', 'metrics_6', 'metrics_7')) then 
		if period_start_ is not null and period_stop_ is not null then
			raise notice 'Rezult: %', row_text_s; -- 1700
			open ref_cursor for execute format('select m.surname, m.firname, m.city_id, m.metrics_insdt, %s 
			from metrics m
			inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
			inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
			inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
			inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
			where m.surname ilike $1 and m.firname ilike $2 and (m.metrics_insdt between $3 and $4) order by m.metrics_insdt', metrics_) using surname_, firname_, period_start_, period_stop_;
			return ref_cursor;
		elsif period_d_w_m_ is not null then
			if period_d_w_m_ = 'DY' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by surname, firname, city_id, period_day order by period_day)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.surname, m.firname, m.city_id, date_trunc($1, m.metrics_insdt) as period_day, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
				where m.surname ilike $2 and m.firname ilike $3)
				select distinct surname, firname, city_id, period_day, %s from cte 
				order by period_day', metrics_, row_fin) using day_, surname_, firname_;
				return ref_cursor;
			elsif period_d_w_m_ = 'WK' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by surname, firname, city_id, period_week order by period_week)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.surname, m.firname, m.city_id, date_trunc($1, m.metrics_insdt) as period_week, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
				where m.surname ilike $2 and m.firname ilike $3)
				select distinct surname, firname, city_id, period_week, %s from cte 
				order by period_week', metrics_, row_fin) using week_, surname_, firname_;
				return ref_cursor;
			elsif period_d_w_m_ = 'MO' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by surname, firname, city_id, period_month order by period_month)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.surname, m.firname, m.city_id, date_trunc($1, m.metrics_insdt) as period_month, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
				where m.surname ilike $2 and m.firname ilike $3)
				select distinct surname, firname, city_id, period_month, %s from cte 
				order by period_month', metrics_, row_fin) using month_, surname_, firname_;
				return ref_cursor;
			end if;			
		elsif period_d_w_m_ is null and period_start_ is null and period_stop_ is null then
			open ref_cursor for execute format('select m.surname, m.firname, m.city_id, m.metrics_insdt, %s 
			from metrics m
			inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
			inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
			inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
			inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
			where m.surname ilike $1 and m.firname ilike $2 order by m.metrics_insdt', metrics_) using surname_, firname_;
			return ref_cursor;
		end if;
	else 
		if period_start_ is not null and period_stop_ is not null then
			raise notice 'Rezult: %', row_text_b; -- 2700
			open ref_cursor for execute format('select m.surname, m.firname, m.city_id, m.metrics_insdt, %s 
			from metrics m
			inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
			inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
			inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
			inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
			where m.surname ilike $1 and m.firname ilike $2 and (m.metrics_insdt between $3 and $4) order by m.metrics_insdt', metrics_) using surname_, firname_, period_start_, period_stop_;
			return ref_cursor;
		elsif period_d_w_m_ is not null then
			if period_d_w_m_ = 'DY' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by surname, firname, city_id, period_day order by period_day)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.surname, m.firname, m.city_id, date_trunc($1, m.metrics_insdt) as period_day, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
				inner join metrics_5 m4 on m5.surname = m.surname and m5.firname = m.firname and m5.city_id = m.city_id and m5.metrics_insdt = m.metrics_insdt
				inner join metrics_6 m4 on m6.surname = m.surname and m6.firname = m.firname and m6.city_id = m.city_id and m6.metrics_insdt = m.metrics_insdt
				inner join metrics_7 m4 on m7.surname = m.surname and m7.firname = m.firname and m7.city_id = m.city_id and m7.metrics_insdt = m.metrics_insdt
				where m.surname ilike $2 and m.firname ilike $3)
				select distinct surname, firname, city_id, period_day, %s from cte 
				order by period_day', metrics_, row_fin) using day_, surname_, firname_;
				return ref_cursor;
			elsif period_d_w_m_ = 'WK' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by surname, firname, city_id, period_week order by period_week)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.surname, m.firname, m.city_id, date_trunc($1, m.metrics_insdt) as period_week, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
				inner join metrics_5 m4 on m5.surname = m.surname and m5.firname = m.firname and m5.city_id = m.city_id and m5.metrics_insdt = m.metrics_insdt
				inner join metrics_6 m4 on m6.surname = m.surname and m6.firname = m.firname and m6.city_id = m.city_id and m6.metrics_insdt = m.metrics_insdt
				inner join metrics_7 m4 on m7.surname = m.surname and m7.firname = m.firname and m7.city_id = m.city_id and m7.metrics_insdt = m.metrics_insdt
				where m.surname ilike $2 and m.firname ilike $3)
				select distinct surname, firname, city_id, period_week, %s from cte 
				order by period_week', metrics_, row_fin) using week_, surname_, firname_;
				return ref_cursor;
			elsif period_d_w_m_ = 'MO' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by surname, firname, city_id, period_month order by period_month)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.surname, m.firname, m.city_id, date_trunc($1, m.metrics_insdt) as period_month, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
				inner join metrics_5 m4 on m5.surname = m.surname and m5.firname = m.firname and m5.city_id = m.city_id and m5.metrics_insdt = m.metrics_insdt
				inner join metrics_6 m4 on m6.surname = m.surname and m6.firname = m.firname and m6.city_id = m.city_id and m6.metrics_insdt = m.metrics_insdt
				inner join metrics_7 m4 on m7.surname = m.surname and m7.firname = m.firname and m7.city_id = m.city_id and m7.metrics_insdt = m.metrics_insdt
				where m.surname ilike $2 and m.firname ilike $3)
				select distinct surname, firname, city_id, period_month, %s from cte 
				order by period_month', metrics_, row_fin) using month_, surname_, firname_;
				return ref_cursor;
			end if;			
		elsif period_d_w_m_ is null and period_start_ is null and period_stop_ is null then
			open ref_cursor for execute format('select m.surname, m.firname, m.city_id, m.metrics_insdt, %s 
			from metrics m
			inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
			inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
			inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
			inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
			inner join metrics_5 m4 on m5.surname = m.surname and m5.firname = m.firname and m5.city_id = m.city_id and m5.metrics_insdt = m.metrics_insdt
			inner join metrics_6 m4 on m6.surname = m.surname and m6.firname = m.firname and m6.city_id = m.city_id and m6.metrics_insdt = m.metrics_insdt
			inner join metrics_7 m4 on m7.surname = m.surname and m7.firname = m.firname and m7.city_id = m.city_id and m7.metrics_insdt = m.metrics_insdt
			where m.surname ilike $1 and m.firname ilike $2 order by m.metrics_insdt', metrics_) using surname_, firname_;
			return ref_cursor;
		end if;
	end if;
end;
$$ language plpgsql;


-- Выводим рефкурсор(весь период):
begin transaction;
select find_human_metrics(surname_ => 'AwrYYWbrlC', firname_ => 'I4AEBwPsBJ', metrics_ => 'twsph, ezevs, qpesh, hoblp, lanzp');
fetch all in ref_cursor;
commit transaction;

-- Выводим рефкурсор(определенный период):
begin transaction;
select find_human_metrics(surname_ => 'AwrYYWbrlC', firname_ => 'I4AEBwPsBJ', metrics_ => 'twsph, ezevs, qpesh, hoblp, lanzp',
period_start_ => '2022-01-04 03:00:00.000', period_stop_ => '2022-01-07 10:00:00.000');
fetch all in ref_cursor;
commit transaction;

-- Выводим рефкурсор(агрегация по дням):
begin transaction;
select find_human_metrics(surname_ => 'AwrYYWbrlC', firname_ => 'I4AEBwPsBJ', metrics_ => 'twsph, ezevs, qpesh, hoblp, lanzp', period_d_w_m_ => 'DY');
fetch all in ref_cursor;
commit transaction;

-- Выводим рефкурсор(агрегация по неделям):
begin transaction;
select find_human_metrics(surname_ => 'AwrYYWbrlC', firname_ => 'I4AEBwPsBJ', metrics_ => 'twsph, ezevs, qpesh, hoblp, lanzp', period_d_w_m_ => 'WK');
fetch all in ref_cursor;
commit transaction;

-- Выводим рефкурсор(агрегация по месяцам):
begin transaction;
select find_human_metrics(surname_ => 'AwrYYWbrlC', firname_ => 'I4AEBwPsBJ', metrics_ => 'twsph, ezevs, qpesh, hoblp, lanzp', period_d_w_m_ => 'MO');
fetch all in ref_cursor;
commit transaction;


-- функция №3 (логика работает, но требуется подкорректировать архитектуру для ускорения запросов по части атрибута city_id)
create or replace function find_city_metrics(metrics_ text, period_start_ timestamp=null, period_stop_ timestamp=null, period_d_w_m_ text=null) returns refcursor as $$
declare 
row_text_s text := '1700 metrics';
row_text_b text := '2700 metrics';
ref_cursor refcursor := 'ref_cursor';
day_ text := quote_ident('day');
week_ text := quote_ident('week');
month_ text := quote_ident('month');
row_list_x text;
row_list_y text array;
row_fin text;

begin 
	if not exists (select * from information_schema.tables where table_name in ('metrics_5', 'metrics_6', 'metrics_7')) then 
		if period_start_ is not null and period_stop_ is not null then
			raise notice 'Rezult: %', row_text_s; -- 1700
			foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
		  	loop     
		    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by m.city_id order by m.metrics_insdt)'||' '||'as'||' '||row_list_x);
			end loop;
		  	row_fin := array_to_string(row_list_y, ', ');  
			
			open ref_cursor for execute format('select distinct m.city_id, m.metrics_insdt, %s 
			from metrics m
			inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
			inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
			inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
			inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
			where m.metrics_insdt between $1 and $2 order by m.city_id', row_fin) using period_start_, period_stop_;
			return ref_cursor;
		elsif period_d_w_m_ is not null then
			if period_d_w_m_ = 'DY' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by city_id order by period_day)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.city_id, date_trunc($1, m.metrics_insdt) as period_day, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt)
				select distinct city_id, period_day, %s from cte 
				order by city_id', metrics_, row_fin) using day_;
				return ref_cursor;
			elsif period_d_w_m_ = 'WK' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by city_id order by period_week)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.city_id, date_trunc($1, m.metrics_insdt) as period_week, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt)
				select distinct city_id, period_week, %s from cte 
				order by city_id', metrics_, row_fin) using week_;
				return ref_cursor;
			elsif period_d_w_m_ = 'MO' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by city_id order by period_month)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.city_id, date_trunc($1, m.metrics_insdt) as period_month, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt)
				select distinct city_id, period_month, %s from cte 
				order by city_id', metrics_, row_fin) using month_;
				return ref_cursor;
			end if;			
		elsif period_d_w_m_ is null and period_start_ is null and period_stop_ is null then
			foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
		  	loop     
		    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by m.city_id order by m.metrics_insdt)'||' '||'as'||' '||row_list_x);
			end loop;
		  	row_fin := array_to_string(row_list_y, ', '); 
		
			open ref_cursor for execute format('select distinct m.city_id, m.metrics_insdt, %s 
			from metrics m
			inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
			inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
			inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
			inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
			order by m.city_id', row_fin);
			return ref_cursor;
		end if;
	else 
		if period_start_ is not null and period_stop_ is not null then
			raise notice 'Rezult: %', row_text_b; -- 2700
			foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
		  	loop     
		    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by m.city_id order by m.metrics_insdt)'||' '||'as'||' '||row_list_x);
			end loop;
		  	row_fin := array_to_string(row_list_y, ', '); 
			
			open ref_cursor for execute format('select distinct m.city_id, m.metrics_insdt, %s 
			from metrics m
			inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
			inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
			inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
			inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
			inner join metrics_5 m4 on m5.surname = m.surname and m5.firname = m.firname and m5.city_id = m.city_id and m5.metrics_insdt = m.metrics_insdt
			inner join metrics_6 m4 on m6.surname = m.surname and m6.firname = m.firname and m6.city_id = m.city_id and m6.metrics_insdt = m.metrics_insdt
			inner join metrics_7 m4 on m7.surname = m.surname and m7.firname = m.firname and m7.city_id = m.city_id and m7.metrics_insdt = m.metrics_insdt
			where m.metrics_insdt between $1 and $2) order by m.city_id', row_fin) using period_start_, period_stop_;
			return ref_cursor;
		elsif period_d_w_m_ is not null then
			if period_d_w_m_ = 'DY' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by city_id order by period_day)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.city_id, date_trunc($1, m.metrics_insdt) as period_day, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt)
				inner join metrics_5 m4 on m5.surname = m.surname and m5.firname = m.firname and m5.city_id = m.city_id and m5.metrics_insdt = m.metrics_insdt
				inner join metrics_6 m4 on m6.surname = m.surname and m6.firname = m.firname and m6.city_id = m.city_id and m6.metrics_insdt = m.metrics_insdt
				inner join metrics_7 m4 on m7.surname = m.surname and m7.firname = m.firname and m7.city_id = m.city_id and m7.metrics_insdt = m.metrics_insdt
				select distinct city_id, period_day, %s from cte 
				order by city_id', metrics_, row_fin) using day_;
				return ref_cursor;
			elsif period_d_w_m_ = 'WK' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by city_id order by period_week)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.city_id, date_trunc($1, m.metrics_insdt) as period_week, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt)
				inner join metrics_5 m4 on m5.surname = m.surname and m5.firname = m.firname and m5.city_id = m.city_id and m5.metrics_insdt = m.metrics_insdt
				inner join metrics_6 m4 on m6.surname = m.surname and m6.firname = m.firname and m6.city_id = m.city_id and m6.metrics_insdt = m.metrics_insdt
				inner join metrics_7 m4 on m7.surname = m.surname and m7.firname = m.firname and m7.city_id = m.city_id and m7.metrics_insdt = m.metrics_insdt
				select distinct city_id, period_week, %s from cte 
				order by city_id', metrics_, row_fin) using week_;
				return ref_cursor;
			elsif period_d_w_m_ = 'MO' then
				foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
			  	loop     
			    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by city_id order by period_month)'||' '||'as'||' '||row_list_x);
				end loop;
			  	row_fin := array_to_string(row_list_y, ', ');  
				
				open ref_cursor for execute format ('with cte as (select m.city_id, date_trunc($1, m.metrics_insdt) as period_month, %s
				from metrics m
				inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
				inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
				inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
				inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt)
				inner join metrics_5 m4 on m5.surname = m.surname and m5.firname = m.firname and m5.city_id = m.city_id and m5.metrics_insdt = m.metrics_insdt
				inner join metrics_6 m4 on m6.surname = m.surname and m6.firname = m.firname and m6.city_id = m.city_id and m6.metrics_insdt = m.metrics_insdt
				inner join metrics_7 m4 on m7.surname = m.surname and m7.firname = m.firname and m7.city_id = m.city_id and m7.metrics_insdt = m.metrics_insdt
				select distinct city_id, period_month, %s from cte 
				order by city_id', metrics_, row_fin) using month_;
				return ref_cursor;
			end if;					
		elsif period_d_w_m_ is null and period_start_ is null and period_stop_ is null then
			foreach row_list_x in array(select string_to_array(metrics_, ', ')) 
		  	loop     
		    	row_list_y := array_append(row_list_y, 'sum('||row_list_x||')'||' '||'over(partition by m.city_id order by m.metrics_insdt)'||' '||'as'||' '||row_list_x);
			end loop;
		  	row_fin := array_to_string(row_list_y, ', '); 
		
			open ref_cursor for execute format('select distinct m.city_id, m.metrics_insdt, %s 
			from metrics m
			inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
			inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
			inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
			inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
			inner join metrics_5 m4 on m5.surname = m.surname and m5.firname = m.firname and m5.city_id = m.city_id and m5.metrics_insdt = m.metrics_insdt
			inner join metrics_6 m4 on m6.surname = m.surname and m6.firname = m.firname and m6.city_id = m.city_id and m6.metrics_insdt = m.metrics_insdt
			inner join metrics_7 m4 on m7.surname = m.surname and m7.firname = m.firname and m7.city_id = m.city_id and m7.metrics_insdt = m.metrics_insdt
			order m.city_id', row_fin);
			return ref_cursor;
		end if;
	end if;
end;
$$ language plpgsql;

-- Выводим рефкурсор(весь период):
begin transaction;
select find_city_metrics(metrics_ => 'twsph, ezevs');
fetch all in ref_cursor;
commit transaction;

-- Выводим рефкурсор(определенный период):
begin transaction;
select find_city_metrics(metrics_ => 'twsph, ezevs',
period_start_ => '2022-01-01 03:00:00.000', period_stop_ => '2022-01-02 10:00:00.000');
fetch all in ref_cursor;
commit transaction;

-- Выводим рефкурсор(агрегация по дням):
begin transaction;
select find_city_metrics(metrics_ => 'twsph, ezevs', period_d_w_m_ => 'DY');
fetch all in ref_cursor;
commit transaction;

-- Выводим рефкурсор(агрегация по неделям):
begin transaction;
select find_city_metrics(metrics_ => 'twsph, ezevs', period_d_w_m_ => 'WK');
fetch all in ref_cursor;
commit transaction;

-- Выводим рефкурсор(агрегация по месяцам):
begin transaction;
select find_city_metrics(metrics_ => 'twsph, ezevs', period_d_w_m_ => 'MO');
fetch all in ref_cursor;
commit transaction;

/* 
with cte as (select m.surname, m.firname, m.city_id, date_trunc('month', m.metrics_insdt) as period_day, twsph 
from metrics m
inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt)
select distinct city_id, period_day, sum(twsph) over(partition by city_id order by period_day) as twsph from cte
order by city_id;
*/

/*
with cte as (select m.city_id, date_trunc('month', m.metrics_insdt) as period_day, twsph 
from metrics m
inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt)
select distinct city_id, period_day, sum(twsph) over(partition by city_id order by period_day) as twsph from cte
order by city_id;
*/

/*
select distinct m.city_id, m.metrics_insdt, sum(twsph) over(partition by m.city_id order by m.metrics_insdt) as twsph
from metrics m
inner join metrics_1 m1 on m1.surname = m.surname and m1.firname = m.firname and m1.city_id = m.city_id and m1.metrics_insdt = m.metrics_insdt
inner join metrics_2 m2 on m2.surname = m.surname and m2.firname = m.firname and m2.city_id = m.city_id and m2.metrics_insdt = m.metrics_insdt
inner join metrics_3 m3 on m3.surname = m.surname and m3.firname = m.firname and m3.city_id = m.city_id and m3.metrics_insdt = m.metrics_insdt
inner join metrics_4 m4 on m4.surname = m.surname and m4.firname = m.firname and m4.city_id = m.city_id and m4.metrics_insdt = m.metrics_insdt
where m.metrics_insdt between '2022-01-01 03:00:00.000' and '2022-01-02 10:00:00.000' order by m.city_id;
*/

create index idx_city on metrics(city_id, metrics_insdt);
create index idx_city_1 on metrics_1(city_id, metrics_insdt);
create index idx_city_2 on metrics_2(city_id, metrics_insdt);
create index idx_city_3 on metrics_3(city_id, metrics_insdt);
create index idx_city_4 on metrics_4(city_id, metrics_insdt);
create index idx_city_5 on metrics_2(city_id, metrics_insdt);
create index idx_city_6 on metrics_3(city_id, metrics_insdt);
create index idx_city_7 on metrics_4(city_id, metrics_insdt);


